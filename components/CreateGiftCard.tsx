import { useState, useEffect } from 'react';
import { Gift, QrCode, Share2, Clock, Lock, Upload, Palette, CheckCircle, AlertCircle, ExternalLink, Mail, MessageCircle, Copy, ChevronDown } from 'lucide-react';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Textarea } from './ui/textarea';
 
import { Switch } from './ui/switch';
import { Checkbox } from './ui/checkbox';
import { Card, CardContent } from './ui/card';
import { Badge } from './ui/badge';
import { Slider } from './ui/slider';
import { Alert, AlertDescription } from './ui/alert';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from './ui/dropdown-menu';
import { RadioGroup, RadioGroupItem } from './ui/radio-group';
import { Collapsible, CollapsibleTrigger, CollapsibleContent } from './ui/collapsible';
import { Tooltip, TooltipContent, TooltipTrigger } from './ui/tooltip';
import { toast } from 'sonner';
import { useAccount, useWalletClient } from 'wagmi';
import { createWalletClient, custom, createPublicClient, http } from 'viem';
import { arcTestnet } from '../utils/web3/wagmiConfig';
import web3Service from '../utils/web3/web3Service';
import { CONTRACT_ADDRESS, USDC_ADDRESS, EURC_ADDRESS, USYC_ADDRESS, ERC20ABI, VAULT_CONTRACT_ADDRESS, TWITCH_VAULT_CONTRACT_ADDRESS, TELEGRAM_VAULT_CONTRACT_ADDRESS, TIKTOK_VAULT_CONTRACT_ADDRESS, INSTAGRAM_VAULT_CONTRACT_ADDRESS } from '../utils/web3/constants';
import pinataService from '../utils/pinata';
import imageGenerator from '../utils/imageGenerator';
import { createTwitterCardMapping } from '../utils/twitter';
import { createTwitchCardMapping } from '../utils/twitch';
import { createTelegramCardMapping } from '../utils/telegram';
import { createTikTokCardMapping } from '../utils/tiktok';
import { createInstagramCardMapping } from '../utils/instagram';
import BridgeDialog from './BridgeDialog';
import { GiftCardsService } from '../utils/supabase/giftCards';
import { useNavigate } from 'react-router-dom';
import { generateBridgeUrlFromArc } from '../utils/bridge/bridgeUrlHelper';
import { usePrivy } from '@privy-io/react-auth';
import { DeveloperWalletService } from '../utils/circle/developerWalletService';
import { apiCall } from '../utils/supabase/client';

interface GiftCardData {
  recipientType: 'address' | 'twitter' | 'twitch' | 'telegram' | 'tiktok' | 'instagram';
  recipientAddress: string;
  recipientUsername: string;
  amount: string;
  currency: 'USDC' | 'EURC' | 'USYC';
  design: 'pink' | 'blue' | 'green' | 'custom';
  message: string;
  secretMessage: string;
  hasTimer: boolean;
  timerHours: number;
  hasPassword: boolean;
  password: string;
  expiryDays: number;
  customImage: string;
  nftCover: string;
}

const SOCIAL_RECIPIENT_OPTIONS = [
  { value: 'twitter', label: 'Twitter' },
  { value: 'twitch', label: 'Twitch' },
  { value: 'telegram', label: 'Telegram' },
  { value: 'tiktok', label: 'TikTok' },
  { value: 'instagram', label: 'Instagram' }
] as const;

export function CreateGiftCard() {
  const { address, isConnected } = useAccount();
  const { data: walletClient } = useWalletClient();
  const { authenticated, user: privyUser } = usePrivy();
  const navigate = useNavigate();
  const [hasDeveloperWallet, setHasDeveloperWallet] = useState(false);
  const [developerWallet, setDeveloperWallet] = useState<any>(null);
  const [checkingWallet, setCheckingWallet] = useState(true);
  const [formData, setFormData] = useState<GiftCardData>({
    recipientType: 'address',
    recipientAddress: '',
    recipientUsername: '',
    amount: '1',
    currency: 'USDC',
    design: 'pink',
    message: '',
    secretMessage: '',
    hasTimer: false,
    timerHours: 24,
    hasPassword: false,
    password: '',
    expiryDays: 365,
    customImage: '',
    nftCover: ''
  });

  const [showAdvanced, setShowAdvanced] = useState(false);
  const [isCreating, setIsCreating] = useState(false);
  const [createdCard, setCreatedCard] = useState<any>(null);
  const [error, setError] = useState('');
  const [step, setStep] = useState<'form' | 'generating' | 'uploading' | 'creating' | 'success'>('form');
  const [isBridgeDialogOpen, setIsBridgeDialogOpen] = useState(false);
  const [highlightField, setHighlightField] = useState<'twitch' | 'twitter' | 'telegram' | 'tiktok' | 'instagram' | null>(null);
  const [isSocialsOpen, setIsSocialsOpen] = useState(formData.recipientType !== 'address');

  // Load selected recipient from localStorage on mount
  useEffect(() => {
    const selectedRecipient = localStorage.getItem('selectedGiftCardRecipient');
    if (selectedRecipient) {
      try {
        const recipient = JSON.parse(selectedRecipient);
        if (recipient.type === 'twitch' && recipient.username) {
          setFormData(prev => ({
            ...prev,
            recipientType: 'twitch',
            recipientUsername: recipient.username
          }));
          // Highlight the field
          setHighlightField('twitch');
          toast.success(`Selected ${recipient.displayName || recipient.username} for gift card`);
          // Clear the stored recipient after using it
          localStorage.removeItem('selectedGiftCardRecipient');
          // Remove highlight after animation
          setTimeout(() => setHighlightField(null), 2000);
        } else if (recipient.type === 'twitter' && recipient.username) {
          setFormData(prev => ({
            ...prev,
            recipientType: 'twitter',
            recipientUsername: recipient.username
          }));
          // Highlight the field
          setHighlightField('twitter');
          toast.success(`Selected ${recipient.displayName || recipient.username} for gift card`);
          localStorage.removeItem('selectedGiftCardRecipient');
          // Remove highlight after animation
          setTimeout(() => setHighlightField(null), 2000);
        } else if (recipient.type === 'telegram' && recipient.username) {
          setFormData(prev => ({
            ...prev,
            recipientType: 'telegram',
            recipientUsername: recipient.username.replace(/^@/, '')
          }));
          setHighlightField('telegram');
          toast.success(`Selected ${recipient.displayName || recipient.username} for gift card`);
          localStorage.removeItem('selectedGiftCardRecipient');
          setTimeout(() => setHighlightField(null), 2000);
        } else if (recipient.type === 'tiktok' && recipient.username) {
          setFormData(prev => ({
            ...prev,
            recipientType: 'tiktok',
            recipientUsername: recipient.username.replace(/^@/, '')
          }));
          setHighlightField('tiktok');
          toast.success(`Selected ${recipient.displayName || recipient.username} for gift card`);
          localStorage.removeItem('selectedGiftCardRecipient');
          setTimeout(() => setHighlightField(null), 2000);
        } else if (recipient.type === 'instagram' && recipient.username) {
          setFormData(prev => ({
            ...prev,
            recipientType: 'instagram',
            recipientUsername: recipient.username.replace(/^@/, '')
          }));
          setHighlightField('instagram');
          toast.success(`Selected ${recipient.displayName || recipient.username} for gift card`);
          localStorage.removeItem('selectedGiftCardRecipient');
          setTimeout(() => setHighlightField(null), 2000);
        } else if (recipient.type === 'address' && recipient.address) {
          setFormData(prev => ({
            ...prev,
            recipientType: 'address',
            recipientAddress: recipient.address
          }));
          toast.success(`Selected ${recipient.displayName || recipient.address.slice(0, 6) + '...' + recipient.address.slice(-4)} for gift card`);
          localStorage.removeItem('selectedGiftCardRecipient');
        }
      } catch (error) {
        console.error('Error parsing selected recipient:', error);
        localStorage.removeItem('selectedGiftCardRecipient');
      }
    }
  }, []);

  const updateFormData = (field: keyof GiftCardData, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  useEffect(() => {
    setIsSocialsOpen(formData.recipientType !== 'address');
  }, [formData.recipientType]);

  // Checking for the presence of a Developer wallet for social networks
  useEffect(() => {
    const checkSocialWallet = async () => {
      // If MetaMask is connected - no need to check a social wallet
      if (isConnected) {
        setHasDeveloperWallet(false);
        setDeveloperWallet(null);
        setCheckingWallet(false);
        return;
      }

      // If no social network is linked - do not check
      if (!authenticated || !privyUser) {
        setHasDeveloperWallet(false);
        setDeveloperWallet(null);
        setCheckingWallet(false);
        return;
      }

      try {
        setCheckingWallet(true);
        // Check for a developer wallet for linked social networks
        const socialPlatforms = ['twitter', 'twitch', 'telegram', 'tiktok', 'instagram'];
        const blockchain = 'ARC-TESTNET';
        
        for (const platform of socialPlatforms) {
          let socialUserId: string | null = null;
          
          if (platform === 'twitter' && privyUser.twitter) {
            socialUserId = (privyUser.twitter as any).subject;
          } else if (platform === 'twitch' && privyUser.twitch) {
            socialUserId = (privyUser.twitch as any).subject;
          } else if (platform === 'telegram' && privyUser.telegram) {
            socialUserId = privyUser.telegram.telegramUserId || (privyUser.telegram as any).subject;
          } else if (platform === 'tiktok' && privyUser.tiktok) {
            socialUserId = (privyUser.tiktok as any).subject;
          } else if (platform === 'instagram' && (privyUser as any).instagram) {
            socialUserId = ((privyUser as any).instagram as any).subject;
          }

          if (socialUserId) {
            const foundWallet = await DeveloperWalletService.getWalletBySocial(
              platform as 'twitter' | 'twitch' | 'telegram' | 'tiktok' | 'instagram',
              socialUserId,
              blockchain
            );
            
            if (foundWallet) {
              setHasDeveloperWallet(true);
              setDeveloperWallet(foundWallet);
              break;
            }
          }
        }
      } catch (error) {
        console.error('Error checking social wallet:', error);
        setHasDeveloperWallet(false);
        setDeveloperWallet(null);
      } finally {
        setCheckingWallet(false);
      }
    };

    checkSocialWallet();
  }, [isConnected, authenticated, privyUser]);

  const handleCreateCard = async () => {
    // Check for a wallet (MetaMask or developer wallet)
    if (!isConnected && !hasDeveloperWallet) {
      setError('Please connect your wallet first');
      return;
    }
    
    // Determine the wallet address to create the card from
    let createAddress: string;
    let useDeveloperWallet = false;
    
    if (isConnected && address) {
      createAddress = address;
    } else if (hasDeveloperWallet && developerWallet) {
      createAddress = developerWallet.wallet_address;
      useDeveloperWallet = true;
    } else {
      setError('Wallet not connected');
      return;
    }

    // Validate based on recipient type
    if (formData.recipientType === 'address') {
      if (!formData.recipientAddress || !formData.recipientAddress.startsWith('0x')) {
        setError('Please enter a valid recipient address');
        return;
      }
    } else if (formData.recipientType === 'twitter') {
      if (!formData.recipientUsername || formData.recipientUsername.trim() === '') {
        setError('Please enter a Twitter username');
        return;
      }
    } else if (formData.recipientType === 'twitch') {
      if (!formData.recipientUsername || formData.recipientUsername.trim() === '') {
        setError('Please enter a Twitch username');
        return;
      }
    } else if (formData.recipientType === 'telegram') {
      if (!formData.recipientUsername || formData.recipientUsername.trim() === '') {
        setError('Please enter a Telegram username');
        return;
      }
    } else if (formData.recipientType === 'tiktok') {
      if (!formData.recipientUsername || formData.recipientUsername.trim() === '') {
        setError('Please enter a TikTok username');
        return;
      }
    } else if (formData.recipientType === 'instagram') {
      if (!formData.recipientUsername || formData.recipientUsername.trim() === '') {
        setError('Please enter an Instagram username');
        return;
      }
    }
    
    if (!formData.amount || parseFloat(formData.amount) <= 0) {
      setError('Please enter a valid amount');
      return;
    }

    setIsCreating(true);
    setError('');

    try {
      // Step 1: Generate image
      setStep('generating');
      toast.info('Generating gift card image...');
      
      const imageBlob = await imageGenerator.generateGiftCardImage({
        amount: formData.amount,
        currency: formData.currency,
        message: formData.message,
        design: formData.design,
        customImage: formData.customImage || undefined
      });

      // Step 2: Upload to Pinata
      setStep('uploading');
      toast.info('Uploading to IPFS...');
      
      const metadataUri = await pinataService.createGiftCardNFT(
        formData.amount,
        formData.currency,
        formData.message,
        formData.design,
        imageBlob
      );

      // Step 3: Check token balance and prepare for creation
      const tokenAddress = formData.currency === 'USDC' ? USDC_ADDRESS : 
                          formData.currency === 'EURC' ? EURC_ADDRESS : 
                          USYC_ADDRESS;
      
      const amountWei = (parseFloat(formData.amount) * 1000000).toString(); // 6 decimals for USDC/EURC
      
      // Check balance for developer wallet
      if (useDeveloperWallet) {
        const publicClient = createPublicClient({
          chain: arcTestnet,
          transport: http()
        });
        
        const balance = await publicClient.readContract({
          address: tokenAddress as `0x${string}`,
          abi: ERC20ABI,
          functionName: 'balanceOf',
          args: [createAddress as `0x${string}`]
        }) as bigint;
        
        if (BigInt(balance) < BigInt(amountWei)) {
          setError(`Insufficient ${formData.currency} balance`);
          setIsCreating(false);
          return;
        }

        // check allowance if need make  approve
        const spenderAddress =
          formData.recipientType === 'twitter' ? VAULT_CONTRACT_ADDRESS :
          formData.recipientType === 'twitch' ? TWITCH_VAULT_CONTRACT_ADDRESS :
          formData.recipientType === 'telegram' ? TELEGRAM_VAULT_CONTRACT_ADDRESS :
          formData.recipientType === 'tiktok' ? TIKTOK_VAULT_CONTRACT_ADDRESS :
          formData.recipientType === 'instagram' ? INSTAGRAM_VAULT_CONTRACT_ADDRESS :
          CONTRACT_ADDRESS;

        const currentAllowance = await publicClient.readContract({
          address: tokenAddress as `0x${string}`,
          abi: ERC20ABI,
          functionName: 'allowance',
          args: [createAddress as `0x${string}`, spenderAddress as `0x${string}`]
        }) as bigint;

        if (currentAllowance < BigInt(amountWei)) {
          toast.info(`Approving ${formData.currency} for contract...`);

          // Send approve via Developer Wallet
          const approveTx = await DeveloperWalletService.sendTransaction({
            walletId: developerWallet.circle_wallet_id,
            walletAddress: developerWallet.wallet_address,
            contractAddress: tokenAddress,
            functionName: 'approve',
            args: [spenderAddress, BigInt(amountWei)],
            blockchain: 'ARC-TESTNET',
            privyUserId: privyUser?.id,
            socialPlatform: developerWallet.social_platform || undefined,
            socialUserId: developerWallet.social_user_id || undefined
          });

          if (!approveTx.success) {
            throw new Error(approveTx.error || 'Approve failed');
          }

          // Wait for approve confirmation (by transactionId)
          if (approveTx.transactionId) {
            const maxAttemptsApprove = 30;
            const pollIntervalApprove = 1000;
            for (let attempt = 0; attempt < maxAttemptsApprove; attempt++) {
              await new Promise(resolve => setTimeout(resolve, pollIntervalApprove));
              try {
                const approveStatus = await apiCall(`/wallets/transaction-status?transactionId=${encodeURIComponent(approveTx.transactionId)}`, { method: 'GET' });
                if (approveStatus?.transactionState === 'COMPLETE') {
                  break;
                }
                if (approveStatus?.transactionState === 'FAILED') {
                  throw new Error(approveStatus?.error || approveStatus?.transaction?.errorDetails || 'Approve transaction failed');
                }
              } catch (pollError) {
                console.warn('Error polling approve status:', pollError);
              }
            }
          }
        }
      }

      // Step 4: Create gift card on blockchain
      setStep('creating');
      toast.info('Creating gift card on blockchain...');
      
      let result;
      
      // Use different methods based on wallet type and recipient type
      if (useDeveloperWallet) {
        // Create card via developer wallet
        const normalizedUsername = formData.recipientType !== 'address' 
          ? formData.recipientUsername.toLowerCase().replace(/^@/, '').trim()
          : '';
        
        let functionName: string;
        let args: any[];
        
        if (formData.recipientType === 'twitter') {
          functionName = 'createGiftCardForTwitter';
          args = [normalizedUsername, BigInt(amountWei), tokenAddress, metadataUri, formData.message];
        } else if (formData.recipientType === 'twitch') {
          functionName = 'createGiftCardForTwitch';
          args = [normalizedUsername, BigInt(amountWei), tokenAddress, metadataUri, formData.message];
        } else if (formData.recipientType === 'telegram') {
          functionName = 'createGiftCardForTelegram';
          args = [normalizedUsername, BigInt(amountWei), tokenAddress, metadataUri, formData.message];
        } else if (formData.recipientType === 'tiktok') {
          functionName = 'createGiftCardForTikTok';
          args = [normalizedUsername, BigInt(amountWei), tokenAddress, metadataUri, formData.message];
        } else if (formData.recipientType === 'instagram') {
          functionName = 'createGiftCardForInstagram';
          args = [normalizedUsername, BigInt(amountWei), tokenAddress, metadataUri, formData.message];
        } else {
          // Address recipient
          functionName = 'createGiftCard';
          args = [formData.recipientAddress, BigInt(amountWei), tokenAddress, metadataUri, formData.message];
        }
        
        // Get social platform info for transaction
        let socialPlatform: string | undefined;
        let socialUserId: string | undefined;
        if (privyUser && developerWallet) {
          socialPlatform = developerWallet.social_platform || undefined;
          socialUserId = developerWallet.social_user_id || undefined;
        }
        
        // Send transaction via developer wallet
        const txResult = await DeveloperWalletService.sendTransaction({
          walletId: developerWallet.circle_wallet_id,
          walletAddress: developerWallet.wallet_address,
          contractAddress: CONTRACT_ADDRESS,
          functionName: functionName,
          args: args,
          blockchain: 'ARC-TESTNET',
          privyUserId: privyUser?.id,
          socialPlatform: socialPlatform,
          socialUserId: socialUserId
        });
        
        if (!txResult.success) {
          throw new Error(txResult.error || 'Failed to create gift card');
        }
        
        // If txHash is not yet available, poll the transaction status until txHash is received
        let finalTxHash = txResult.txHash;
        if (!finalTxHash && txResult.transactionId) {
          toast.info('Waiting for transaction to be processed...');
          
          // Poll transaction status via Circle API
          const maxAttempts = 30; // Maximum 30 attempts (~30 seconds)
          const pollInterval = 1000; // 1 second between attempts
          
          for (let attempt = 0; attempt < maxAttempts; attempt++) {
            await new Promise(resolve => setTimeout(resolve, pollInterval));
            
              try {
                // Use common apiCall helper to set Authorization
              const statusData = await apiCall(`/wallets/transaction-status?transactionId=${encodeURIComponent(txResult.transactionId)}`, {
                method: 'GET'
              });
              
              if (statusData) {
                if (statusData.txHash) {
                  finalTxHash = statusData.txHash;
                  break;
                }
                // If the transaction failed
                if (statusData.transactionState === 'FAILED') {
                  throw new Error(statusData.error || 'Transaction failed');
                }
              }
            } catch (pollError) {
              console.warn('Error polling transaction status:', pollError);
              // Continue polling
            }
          }
          
          if (!finalTxHash) {
            // If there is still no txHash, use transactionId for display
            // and show a message to the user
            toast.warning('Transaction is being processed. Please check status later.');
            // Use transactionId as a temporary identifier
            finalTxHash = txResult.transactionId || 'pending';
          }
        }
        
        if (!finalTxHash) {
          throw new Error('Failed to get transaction hash');
        }
        
        // If txHash is not ready yet (pending), do not wait for receipt
        if (finalTxHash === 'pending' || finalTxHash === txResult.transactionId) {
          // Use transactionId to store the card
          result = {
            tokenId: 'pending', // Will be updated later
            txHash: txResult.transactionId || 'pending'
          };
        } else {
          // Wait for transaction receipt and extract tokenId
          const publicClient = createPublicClient({
            chain: arcTestnet,
            transport: http()
          });
          
          const receipt = await publicClient.waitForTransactionReceipt({
            hash: finalTxHash as `0x${string}`
          });
          
          // Check transaction status - if it failed, throw an error
          if (receipt.status === 'reverted' || receipt.status === 0) {
            throw new Error(`Transaction failed: ERC20 transfer amount exceeds balance or other contract error. Transaction hash: ${finalTxHash}`);
          }
          
          // Extract tokenId from Transfer event
          const transferEventSignature = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
          const zeroAddress = '0x0000000000000000000000000000000000000000';
          const zeroAddressTopic = '0x' + zeroAddress.slice(2).padStart(64, '0');
          
          let tokenId = '1'; // Default fallback
          const transferEvent = receipt.logs.find((log: any) => 
            log.topics[0] === transferEventSignature &&
            log.topics[1]?.toLowerCase() === zeroAddressTopic.toLowerCase() &&
            (log.address.toLowerCase() === CONTRACT_ADDRESS.toLowerCase() ||
             log.address.toLowerCase() === (formData.recipientType === 'twitter' ? VAULT_CONTRACT_ADDRESS :
                                          formData.recipientType === 'twitch' ? TWITCH_VAULT_CONTRACT_ADDRESS :
                                          formData.recipientType === 'telegram' ? TELEGRAM_VAULT_CONTRACT_ADDRESS :
                                          formData.recipientType === 'tiktok' ? TIKTOK_VAULT_CONTRACT_ADDRESS :
                                          formData.recipientType === 'instagram' ? INSTAGRAM_VAULT_CONTRACT_ADDRESS :
                                          CONTRACT_ADDRESS).toLowerCase())
          );
          
          if (transferEvent && transferEvent.topics[3]) {
            tokenId = BigInt(transferEvent.topics[3]).toString();
          }
          
          result = {
            tokenId: tokenId,
            txHash: finalTxHash
          };
        }
      } else {
        // Create card via MetaMask (existing logic)
        // Initialize web3 service
        let clientToUse = walletClient;
        if (!clientToUse) {
          console.log('wagmi walletClient not available, creating manual client...');
          clientToUse = createWalletClient({
            chain: arcTestnet,
            transport: custom(window.ethereum)
          });
        }

        await web3Service.initialize(clientToUse, createAddress);
        
        // Use different methods based on recipient type
        if (formData.recipientType === 'twitter') {
          // Normalize username for consistency (createCardForTwitter also normalizes)
          const normalizedUsername = formData.recipientUsername.toLowerCase().replace(/^@/, '').trim();
          console.log('[CreateGiftCard] Creating Twitter card:', {
            original: formData.recipientUsername,
            normalized: normalizedUsername
          });
          
          // Use new Vault flow for Twitter cards
          result = await web3Service.createCardForTwitter(
            normalizedUsername, // Using normalized username
            formData.amount,
            formData.currency,
            metadataUri,
            formData.message
          );
          
          // Still save metadata to KV for additional info (using normalized username)
          try {
            await createTwitterCardMapping({
              tokenId: result.tokenId,
              username: normalizedUsername, // Saving normalized username
              temporaryOwner: '', // No longer needed with Vault
              senderAddress: createAddress,
              amount: formData.amount,
              currency: formData.currency,
              message: formData.message,
              metadataUri: metadataUri
            });
          } catch (error) {
            console.error('Error saving Twitter card metadata:', error);
            // Non-critical error, card is already created on blockchain
          }
        } else if (formData.recipientType === 'twitch') {
          const normalizedUsername = formData.recipientUsername.toLowerCase().trim();
          console.log('[CreateGiftCard] Creating Twitch card:', {
            original: formData.recipientUsername,
            normalized: normalizedUsername
          });
          
          result = await web3Service.createCardForTwitch(
            normalizedUsername,
            formData.amount,
            formData.currency,
            metadataUri,
            formData.message
          );
          
          try {
            await createTwitchCardMapping({
              tokenId: result.tokenId,
              username: normalizedUsername,
              temporaryOwner: '',
              senderAddress: createAddress,
              amount: formData.amount,
              currency: formData.currency,
              message: formData.message,
              metadataUri: metadataUri
            });
          } catch (error) {
            console.error('Error saving Twitch card metadata:', error);
          }
        } else if (formData.recipientType === 'telegram') {
          const normalizedUsername = formData.recipientUsername.toLowerCase().replace(/^@/, '').trim();
          console.log('[CreateGiftCard] Creating Telegram card:', {
            original: formData.recipientUsername,
            normalized: normalizedUsername
          });

          result = await web3Service.createCardForTelegram(
            normalizedUsername,
            formData.amount,
            formData.currency,
            metadataUri,
            formData.message
          );

          try {
            await createTelegramCardMapping({
              tokenId: result.tokenId,
              username: normalizedUsername,
              temporaryOwner: '',
              senderAddress: createAddress,
              amount: formData.amount,
              currency: formData.currency,
              message: formData.message,
              metadataUri: metadataUri
            });
          } catch (error) {
            console.error('Error saving Telegram card metadata:', error);
          }
        } else if (formData.recipientType === 'tiktok') {
          const normalizedUsername = formData.recipientUsername.toLowerCase().replace(/^@/, '').trim();
          console.log('[CreateGiftCard] Creating TikTok card:', {
            original: formData.recipientUsername,
            normalized: normalizedUsername
          });

          result = await web3Service.createCardForTikTok(
            normalizedUsername,
            formData.amount,
            formData.currency,
            metadataUri,
            formData.message
          );

          try {
            await createTikTokCardMapping({
              tokenId: result.tokenId,
              username: normalizedUsername,
              temporaryOwner: '',
              senderAddress: createAddress,
              amount: formData.amount,
              currency: formData.currency,
              message: formData.message,
              metadataUri: metadataUri
            });
          } catch (error) {
            console.error('Error saving TikTok card metadata:', error);
          }
        } else if (formData.recipientType === 'instagram') {
          const normalizedUsername = formData.recipientUsername.toLowerCase().replace(/^@/, '').trim();
          console.log('[CreateGiftCard] Creating Instagram card:', {
            original: formData.recipientUsername,
            normalized: normalizedUsername
          });

          result = await web3Service.createCardForInstagram(
            normalizedUsername,
            formData.amount,
            formData.currency,
            metadataUri,
            formData.message
          );

          try {
            await createInstagramCardMapping({
              tokenId: result.tokenId,
              username: normalizedUsername,
              temporaryOwner: '',
              senderAddress: createAddress,
              amount: formData.amount,
              currency: formData.currency,
              message: formData.message,
              metadataUri: metadataUri
            });
          } catch (error) {
            console.error('Error saving Instagram card metadata:', error);
          }
        } else {
          // Standard flow for address recipients
          result = await web3Service.createGiftCard(
            formData.recipientAddress,
            formData.amount,
            formData.currency,
            metadataUri,
            formData.message
          );
        }
      }

      setStep('success');
      
      const createdCardData = {
        id: result.tokenId,
        recipientAddress: formData.recipientAddress,
        amount: formData.amount,
        currency: formData.currency,
        design: formData.design,
        message: formData.message,
        secretMessage: formData.secretMessage,
        hasTimer: formData.hasTimer,
        timerHours: formData.timerHours,
        hasPassword: formData.hasPassword,
        expiryDays: formData.expiryDays,
        customImage: formData.customImage,
        nftCover: formData.nftCover,
        status: 'active',
        created_at: new Date().toISOString(),
        expires_at: new Date(Date.now() + formData.expiryDays * 24 * 60 * 60 * 1000).toISOString(),
        qr_code: `sendly://redeem/${result.tokenId}`,
        tx_hash: result.txHash,
        metadata_uri: metadataUri
      };

      setCreatedCard(createdCardData);
      toast.success(`Gift card created successfully! Token ID: ${result.tokenId}`);
      toast.success(`Gift card created successfully! TX: ${result.txHash.slice(0, 10)}...${result.txHash.slice(-8)}`);
      
      // Save to Supabase for caching
      try {
        const recipientUsernameForStorage =
          formData.recipientType === 'address'
            ? null
            : formData.recipientUsername.replace(/^@/, '').trim();
        await GiftCardsService.upsertCard({
          token_id: result.tokenId,
          sender_address: (createAddress || '').toLowerCase(),
          recipient_address: formData.recipientType === 'address' ? formData.recipientAddress.toLowerCase() : null,
          recipient_username: recipientUsernameForStorage,
          recipient_type: formData.recipientType,
          amount: formData.amount,
          currency: formData.currency,
          message: formData.message,
          redeemed: false,
          tx_hash: result.txHash,
        });
        console.log('Card saved to Supabase cache');
      } catch (error) {
        console.error('Error saving card to Supabase:', error);
      }
      
      // Reset form
      setFormData({
        recipientType: 'address',
        recipientAddress: '',
        recipientUsername: '',
        amount: '1',
        currency: 'USDC',
        design: 'pink',
        message: '',
        secretMessage: '',
        hasTimer: false,
        timerHours: 24,
        hasPassword: false,
        password: '',
        expiryDays: 7,
        customImage: '',
        nftCover: ''
      });
    } catch (error) {
      console.error('Error creating gift card:', error);
      
      // Check if it's a chain ID error with Coinbase Wallet
      const errorMessage = error instanceof Error ? error.message : 'Failed to create gift card';
      if (errorMessage.includes('invalid chain ID') && typeof window !== 'undefined' && (window as any).ethereum?.isCoinbaseWallet) {
        setError('Coinbase Wallet has issues with Arc Testnet. Please use MetaMask or Rainbow Wallet to work with Arc Testnet.');
        toast.error('Error: use MetaMask or Rainbow Wallet', {
          description: 'Coinbase Wallet is not supported for Arc Testnet'
        });
      } else if (errorMessage.includes('ERC20') || errorMessage.includes('transfer amount exceeds balance') || errorMessage.includes('Transaction failed')) {
        // More specific error for balance/transfer issues
        const displayMessage = errorMessage.includes('Transaction failed') 
          ? errorMessage 
          : `Insufficient ${formData.currency} balance. Please ensure you have enough tokens to create this gift card.`;
        setError(displayMessage);
        toast.error('Transaction failed', {
          description: displayMessage
        });
      } else {
        setError(errorMessage);
        toast.error('Failed to create gift card', {
          description: errorMessage
        });
      }
    } finally {
      setIsCreating(false);
      setStep('form');
    }
  };

  const handleShare = (method?: 'email' | 'x' | 'tiktok' | 'copy') => {
    if (!createdCard) return;
    
    const shareUrl = `${window.location.origin}/redeem/${createdCard.id}`;
    const shareText = `ðŸŽ Receive a Sendly gift card for $${createdCard.amount} ${createdCard.currency}! ${shareUrl}`;
    
    if (method === 'email') {
      const mailtoLink = `mailto:?subject=ðŸŽ Sendly Gift Card&body=${encodeURIComponent(shareText)}`;
      window.location.href = mailtoLink;
      toast.success('Email app opened');
    } else if (method === 'x') {
      const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}`;
      window.open(twitterUrl, '_blank');
      toast.success('Twitter opened for posting');
    } else if (method === 'tiktok') {
      navigator.clipboard.writeText(shareUrl);
      toast.success('Link copied! Paste it in TikTok');
    } else {
      navigator.clipboard.writeText(shareUrl);
      toast.success('Link copied to clipboard!');
    }
  };

  const getCardColor = () => {
    switch (formData.design) {
      case 'pink': return 'from-pink-400 to-purple-500';
      case 'blue': return 'from-blue-400 to-cyan-500';
      case 'green': return 'from-green-400 to-emerald-500';
      default: return 'from-gray-400 to-gray-600';
    }
  };

  const getStepText = () => {
    switch (step) {
      case 'generating': return 'Generating image...';
      case 'uploading': return 'Uploading to IPFS...';
      case 'creating': return 'Creating on blockchain...';
      case 'success': return 'Success!';
      default: return 'Create a card';
    }
  };

  const openCircleBridge = () => {
    const baseUrl = import.meta.env.VITE_CIRCLE_BRIDGE_URL || 'https://faucet.circle.com/';
    const url = baseUrl;
    window.open(url, '_blank', 'noopener,noreferrer');
  };

  // Show the message only if there is neither MetaMask nor a social Developer wallet
  if (!isConnected && !hasDeveloperWallet) {
    if (checkingWallet) {
      return (
        <div className="p-6 text-center">
          <div className="flex items-center justify-center gap-2">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
            <span className="text-sm text-gray-600">Checking wallet...</span>
          </div>
        </div>
      );
    }

    return (
      <div className="p-6 text-center">
        <Alert>
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            Please connect your wallet or social account to create gift cards
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div className="p-6 space-y-6">
      <h2 className="text-2xl font-semibold">Create a gift card</h2>
      
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Form Section */}
        <div className="space-y-4">
          <div>
            <Label>Recipient type</Label>
            <RadioGroup
              value={formData.recipientType}
              onValueChange={(value: 'address' | 'twitter' | 'twitch' | 'telegram' | 'tiktok' | 'instagram') => updateFormData('recipientType', value)}
              className="mt-2 space-y-3"
            >
              <div className="flex items-center space-x-2">
                <RadioGroupItem value="address" id="address" />
                <Label htmlFor="address" className="cursor-pointer font-normal">
                  Wallet address
                </Label>
              </div>
              <Collapsible open={isSocialsOpen} onOpenChange={setIsSocialsOpen}>
                <CollapsibleTrigger asChild>
                  <Button
                    type="button"
                    variant="outline"
                    className="flex w-full items-center justify-between bg-muted/20"
                  >
                    <span>Socials</span>
                    <ChevronDown
                      className={`h-4 w-4 transition-transform ${isSocialsOpen ? 'rotate-180' : ''}`}
                    />
                  </Button>
                </CollapsibleTrigger>
                <CollapsibleContent className="mt-3 space-y-2 rounded-lg border border-dashed border-gray-200 p-3">
                  {SOCIAL_RECIPIENT_OPTIONS.map((option) => {
                    const isReceivingDisabled = option.value === 'tiktok' || option.value === 'instagram';
                    const content = (
                      <div className="flex items-center space-x-2">
                        <RadioGroupItem value={option.value} id={option.value} disabled={isReceivingDisabled} />
                        <Label htmlFor={option.value} className={`cursor-pointer font-normal ${isReceivingDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}>
                          {option.label}
                        </Label>
                      </div>
                    );

                    if (isReceivingDisabled) {
                      return (
                        <Tooltip key={option.value}>
                          <TooltipTrigger asChild>{content}</TooltipTrigger>
                          <TooltipContent className="max-w-[220px] text-center">
                            Receiving funds is not available yet
                          </TooltipContent>
                        </Tooltip>
                      );
                    }

                    return (
                      <div key={option.value} className="flex items-center space-x-2">
                        <RadioGroupItem value={option.value} id={option.value} />
                        <Label htmlFor={option.value} className="cursor-pointer font-normal">
                          {option.label}
                        </Label>
                      </div>
                    );
                  })}
                </CollapsibleContent>
              </Collapsible>
            </RadioGroup>
          </div>

          {formData.recipientType === 'address' ? (
            <div>
              <Label htmlFor="recipient">Recipient address (0x)</Label>
              <Input
                id="recipient"
                placeholder="0x..."
                value={formData.recipientAddress}
                onChange={(e) => updateFormData('recipientAddress', e.target.value)}
                className="mt-2"
              />
            </div>
          ) : formData.recipientType === 'twitter' ? (
            <div>
              <Label htmlFor="username">Twitter username</Label>
              <Input
                id="username"
                placeholder="username"
                value={formData.recipientUsername}
                onChange={(e) => {
                  let username = e.target.value;
                  if (username.startsWith('@')) {
                    username = username.slice(1);
                  }
                  updateFormData('recipientUsername', username);
                }}
                className={`mt-2 transition-all duration-500 ${
                  highlightField === 'twitter' 
                    ? 'bg-blue-50 border-blue-400 ring-2 ring-blue-300 shadow-md' 
                    : ''
                }`}
              />
              <p className="text-xs text-gray-500 mt-1">
                The recipient will need to login via Privy with Twitter to claim the card.
              </p>
            </div>
          ) : formData.recipientType === 'twitch' ? (
            <div>
              <Label htmlFor="username">Twitch username</Label>
              <Input
                id="username"
                placeholder="username"
                value={formData.recipientUsername}
                onChange={(e) => {
                  const username = e.target.value.trim();
                  updateFormData('recipientUsername', username);
                }}
                className={`mt-2 transition-all duration-500 ${
                  highlightField === 'twitch' 
                    ? 'bg-purple-50 border-purple-400 ring-2 ring-purple-300 shadow-md' 
                    : ''
                }`}
              />
              <p className="text-xs text-gray-500 mt-1">
                The recipient will need to login via Privy with Twitch to claim the card.
              </p>
            </div>
          ) : formData.recipientType === 'telegram' ? (
            <div>
              <Label htmlFor="username">Telegram username</Label>
              <Input
                id="username"
                placeholder="nickname"
                value={formData.recipientUsername}
                onChange={(e) => {
                  let username = e.target.value.trim();
                  if (username.startsWith('@')) {
                    username = username.slice(1);
                  }
                  updateFormData('recipientUsername', username);
                }}
                className={`mt-2 transition-all duration-500 ${
                  highlightField === 'telegram'
                    ? 'bg-sky-50 border-sky-400 ring-2 ring-sky-300 shadow-md'
                    : ''
                }`}
              />
              <p className="text-xs text-gray-500 mt-1">
                The recipient will need to login via Privy with Telegram to claim the card.
              </p>
            </div>
          ) : formData.recipientType === 'tiktok' ? (
            <div>
              <Label htmlFor="username">TikTok username</Label>
              <Input
                id="username"
                placeholder="nickname"
                value={formData.recipientUsername}
                onChange={(e) => {
                  let username = e.target.value.trim();
                  if (username.startsWith('@')) {
                    username = username.slice(1);
                  }
                  updateFormData('recipientUsername', username);
                }}
                className={`mt-2 transition-all duration-500 ${
                  highlightField === 'tiktok'
                    ? 'bg-neutral-900/10 border-black ring-2 ring-neutral-400 shadow-md'
                    : ''
                }`}
              />
              <p className="text-xs text-gray-500 mt-1">
                The recipient will need to login via Privy with TikTok to claim the card.
              </p>
            </div>
          ) : (
            <div>
              <Label htmlFor="username">Instagram username</Label>
              <Input
                id="username"
                placeholder="nickname"
                value={formData.recipientUsername}
                onChange={(e) => {
                  let username = e.target.value.trim();
                  if (username.startsWith('@')) {
                    username = username.slice(1);
                  }
                  updateFormData('recipientUsername', username);
                }}
                className={`mt-2 transition-all duration-500 ${
                  highlightField === 'instagram'
                    ? 'bg-pink-50 border-pink-400 ring-2 ring-pink-300 shadow-md'
                    : ''
                }`}
              />
              <p className="text-xs text-gray-500 mt-1">
                The recipient will need to login via Privy with Instagram to claim the card.
              </p>
            </div>
          )}

          <div>
            <Label htmlFor="amount">Amount (in $)</Label>
            <Input
              id="amount"
              type="number"
              placeholder="10"
              value={formData.amount}
              onChange={(e) => updateFormData('amount', e.target.value)}
              className="mt-2"
            />
          </div>

          <div>
            <Label>Card design</Label>
            <div className="flex gap-2 mt-2">
              {[
                { value: 'pink', label: 'Pink', color: 'bg-pink-400' },
                { value: 'blue', label: 'Blue', color: 'bg-blue-400' },
                { value: 'green', label: 'Green', color: 'bg-green-400' },
              ].map((design) => (
                <Button
                  key={design.value}
                  variant={formData.design === design.value ? "default" : "outline"}
                  size="sm"
                  onClick={() => updateFormData('design', design.value)}
                  className="flex items-center gap-2"
                >
                  <div className={`w-3 h-3 rounded-full ${design.color}`}></div>
                  {design.label}
                </Button>
              ))}
            </div>
          </div>

          <div className="flex gap-4">
            <div className="flex-1">
              <Label>Currency</Label>
              <Select
                value={formData.currency}
                onValueChange={(value: 'USDC' | 'EURC' | 'USYC') => updateFormData('currency', value)}
              >
                <SelectTrigger className="mt-2">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="USDC">USDC</SelectItem>
                  <SelectItem value="EURC">EURC</SelectItem>
                  <SelectItem value="USYC">USYC</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>

        {/* Preview Section */}
        <div className="space-y-4">
          <Label>Preview of gift card</Label>
          
          <Card className={`bg-gradient-to-br ${getCardColor()} text-white border-0 shadow-lg`}>
            <CardContent className="p-6 text-center">
              <div className="space-y-4">
                <div className="flex items-center justify-center gap-2">
                  <Gift className="w-6 h-6" />
                  <span className="text-lg font-medium">Gift Card</span>
                </div>
                
                <div className="text-4xl font-bold">
                  ${formData.amount || '0'}
                </div>
                
                <div className="text-sm opacity-90">
                  {formData.currency}
                </div>
                
                {formData.message && (
                  <div className="text-sm bg-white/20 rounded-lg p-3 mt-4">
                    "{formData.message}"
                  </div>
                )}

                <div className="flex flex-wrap gap-2 justify-center mt-4">
                  {formData.hasTimer && (
                    <Badge variant="secondary" className="bg-white/20 text-white">
                      <Clock className="w-3 h-3 mr-1" />
                      {formData.timerHours}h delay
                    </Badge>
                  )}
                  {formData.hasPassword && (
                    <Badge variant="secondary" className="bg-white/20 text-white">
                      <Lock className="w-3 h-3 mr-1" />
                      Protected
                    </Badge>
                  )}
                  {formData.expiryDays < 365 && (
                    <Badge variant="secondary" className="bg-white/20 text-white">
                      {formData.expiryDays}d expiry
                    </Badge>
                  )}
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Action Buttons */}
          <div className="space-y-2">
            <Button 
              variant="outline"
              className="w-full"
              size="sm"
              onClick={openCircleBridge}
              disabled={formData.currency === 'USYC'}
              title={formData.currency === 'USYC' ? 'Bridge support for USYC is coming soon' : undefined}
            >
              <ExternalLink className="w-4 h-4 mr-2" />
              Top up {formData.currency} on Arc (Circle Bridge)
            </Button>
            <Button 
              variant="outline"
              className="w-full"
              size="sm"
              onClick={() => {
                const bridgeUrl = generateBridgeUrlFromArc('base-sepolia', formData.currency);
                navigate(bridgeUrl);
              }}
              disabled={formData.currency === 'USYC'}
              title={formData.currency === 'USYC' ? 'Bridge support for USYC is coming soon' : undefined}
            >
              <ExternalLink className="w-4 h-4 mr-2" />
              Bridge {formData.currency} to Base Sepolia
            </Button>
            <Button 
              className="w-full" 
              size="lg" 
              onClick={handleCreateCard}
              disabled={isCreating}
            >
              {isCreating ? getStepText() : 'Create a card'}
            </Button>
            
            <div className="flex gap-2">
              <Button 
                variant="outline" 
                size="sm" 
                className="flex-1"
                disabled={!createdCard}
              >
                <QrCode className="w-4 h-4 mr-2" />
                Generate QR
              </Button>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button 
                    variant="outline" 
                    size="sm" 
                    className="flex-1"
                    disabled={!createdCard}
                  >
                    <Share2 className="w-4 h-4 mr-2" />
                    Share
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => handleShare('email')}>
                    <Mail className="w-4 h-4 mr-2" />
                    Send via Email
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => handleShare('x')}>
                    <MessageCircle className="w-4 h-4 mr-2" />
                    Share on X (Twitter)
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => handleShare('tiktok')}>
                    <Share2 className="w-4 h-4 mr-2" />
                    Share on TikTok
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => handleShare('copy')}>
                    <Copy className="w-4 h-4 mr-2" />
                    Copy link
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
            
            {/* <div className="flex flex-col items-start space-y-1"> 
             {/* <div className="flex items-center space-x-2 text-sm text-gray-600">
                <input type="checkbox" id="paymaster" disabled className="opacity-50 cursor-not-allowed" />
                <Label htmlFor="paymaster" className="opacity-50 cursor-not-allowed">Use paymaster</Label>
              </div>
              <span className="text-gray-500 text-xs ml-5">Coming soon</span>
            </div> */}
          </div>

          {/* Error Display */}
          {error && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          {/* Success Display */}
          {createdCard && (
            <Alert>
              <CheckCircle className="h-4 w-4" />
              <AlertDescription className="space-y-2">
                <div>Gift card created successfully! Token ID: {createdCard.id}</div>
                <div className="text-sm">
                  TX: 
                  <button
                    onClick={() => {
                      const explorer = import.meta.env.VITE_ARC_BLOCK_EXPLORER_URL || 'https://testnet.arcscan.app';
                      window.open(`${explorer}/tx/${createdCard.tx_hash}`, '_blank');
                    }}
                    className="text-blue-600 hover:text-blue-800 hover:underline cursor-pointer transition-colors ml-1"
                    title={`View on Arc Explorer: ${createdCard.tx_hash}`}
                  >
                    {createdCard.tx_hash.slice(0, 10)}...{createdCard.tx_hash.slice(-8)}
                  </button>
                </div>
              </AlertDescription>
            </Alert>
          )}
        </div>

        {/* Message field - spans both columns */}
        <div className="lg:col-span-2">
          <Label htmlFor="message">Message</Label>
          <Textarea
            id="message"
            placeholder="Your message here..."
            value={formData.message}
            onChange={(e) => updateFormData('message', e.target.value)}
            className="mt-2 w-full"
          />
        </div>

        {/* Advanced Features Toggle */}
        <div className="lg:col-span-2 flex items-center space-x-2 -mt-4">
          <Tooltip>
            <TooltipTrigger asChild>
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="advanced"
                  checked={showAdvanced}
                  disabled
                  onCheckedChange={(checked) => {
                    if (typeof checked === 'boolean') {
                      setShowAdvanced(checked);
                    }
                  }}
                />
                <Label htmlFor="advanced" className="cursor-not-allowed opacity-50">Advanced features</Label>
              </div>
            </TooltipTrigger>
            <TooltipContent>
              <p>Sorry, this feature is temporarily unavailable</p>
            </TooltipContent>
          </Tooltip>
        </div>
      </div>

      {/* Advanced Features - Full width, below grid */}
      {showAdvanced && (
        <div className="space-y-3 p-4 bg-gray-50 rounded-lg border border-gray-200">
          {/* Secret Message */}
          <div>
            <Label htmlFor="secret" className="text-base font-medium">Secret message (revealed after activation)</Label>
            <Textarea
              id="secret"
              placeholder="A special message or promo code..."
              value={formData.secretMessage}
              onChange={(e) => updateFormData('secretMessage', e.target.value)}
              className="mt-2"
              rows={4}
            />
          </div>

          {/* Timer Feature */}
          <div className="flex items-center space-x-2">
            <Switch
              id="timer"
              checked={formData.hasTimer}
              onCheckedChange={(checked) => updateFormData('hasTimer', checked)}
            />
            <Label htmlFor="timer" className="text-base font-medium cursor-pointer">Open later (timer)</Label>
          </div>

          {formData.hasTimer && (
            <div className="pl-6 space-y-1">
              <Label className="text-base">Hours until card can be opened: {formData.timerHours}h</Label>
              <Slider
                value={[formData.timerHours]}
                onValueChange={(value) => updateFormData('timerHours', value[0])}
                max={168}
                min={1}
                step={1}
                className="mt-2 w-full"
              />
            </div>
          )}

          {/* Password Protection */}
          <div className="flex items-center space-x-2">
            <Switch
              id="password"
              checked={formData.hasPassword}
              onCheckedChange={(checked) => updateFormData('hasPassword', checked)}
            />
            <Label htmlFor="password" className="text-base font-medium cursor-pointer">Password protection</Label>
          </div>

          {formData.hasPassword && (
            <div className="pl-6">
              <Input
                placeholder="Enter password"
                type="password"
                value={formData.password}
                onChange={(e) => updateFormData('password', e.target.value)}
                className="mt-2 w-full"
              />
            </div>
          )}

          {/* Expiry */}
          <div className="space-y-2">
            <Label className="text-base font-medium">Card expires in: {formData.expiryDays} days</Label>
            <Slider
              value={[formData.expiryDays]}
              onValueChange={(value) => updateFormData('expiryDays', value[0])}
              max={365}
              min={1}
              step={1}
              className="mt-2 w-full"
            />
          </div>

          {/* Custom Design Upload */}
          <div className="space-y-2">
            <Label className="text-base font-medium">Custom design</Label>
            <div className="flex gap-2">
              <Button variant="outline" size="default" className="flex-1">
                <Upload className="w-4 h-4 mr-2" />
                Upload Image
              </Button>
              <Button variant="outline" size="default" className="flex-1">
                <Palette className="w-4 h-4 mr-2" />
                AI Generate
              </Button>
            </div>
          </div>

          {/* NFT Cover */}
          <div className="space-y-1">
            <Label htmlFor="nft" className="text-base font-medium">NFT Cover (optional)</Label>
            <Input
              id="nft"
              placeholder="NFT contract address or OpenSea URL"
              value={formData.nftCover}
              onChange={(e) => updateFormData('nftCover', e.target.value)}
              className="mt-2 w-full"
            />
          </div>
        </div>
      )}

      <BridgeDialog 
        open={isBridgeDialogOpen} 
        onOpenChange={setIsBridgeDialogOpen} 
      />
    </div>
  );
}